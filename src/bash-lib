#!/bin/bash

# set -a # to export functions # unintended side-effects; using export -f instead

export NORM=$(tput sgr0)
export BOLD=$(tput bold)
export RED=$(tput setaf 1)
export GRE=$(tput setaf 2)

function task {
    task_name=${1:-default}
    [ -z "$VARS" ] && load_vars
    task_file=$(taskfile $task_name)
    [ -z "$task_file" ] && echo -e "Task ${BOLD}$task_name${NORM} not found" && exit 1
    chmod +x "$task_file"
    echo -e "${NORM}‚ö°Ô∏è Task ${BOLD}$task_name${NORM} started" # Source: $task_file"
    time_before=$(now)
    "$task_file" "${@:2}"
    exit_code=$?
    time_after=$(now)
    time_taken_ms=$((time_after-time_before))
    time_taken_s=$(echo "scale=1;${time_taken_ms}/1000" | bc)
    [[ $time_taken_s == .* ]] && time_taken_s="0$time_taken_s"
    [ $exit_code = 0 ] && icon="‚úÖ" || icon="‚ùå"
    echo -e "${NORM}${icon} Task ${BOLD}$task_name${NORM} completed with exit code $exit_code in ${time_taken_ms}ms (${time_taken_s}s)"
    exit $exit_code
}

function load_vars {
    export STAGE=${STAGE:-"local"}
    export TASK_LIBRARY_ROOT="./node_modules/task-library"
    export TASK_LIBRARY_SRC="$TASK_LIBRARY_ROOT/src"
    export TASK_LIBRARY_LIB="$TASK_LIBRARY_SRC/lib"
    export TASK_LIBRARY_NODE_BIN="$TASK_LIBRARY_SRC/bin"
    export TASK_LIBRARY_TASKS="$TASK_LIBRARY_SRC/tasks"

    task_vars="./task-vars"
    var_definitions="$TASK_LIBRARY_SRC/var-definitions"

    funcs=$(extract_function_names "$var_definitions")
    source "$var_definitions"

    while IFS= read -r name; do
        export -f "$name"
    done <<< "$funcs"

    env_before="$(env)"
    [ -f "$task_vars" ] && source "$task_vars"

    while IFS= read -r name; do
        [ -z "${!name}" ] && export $name="$($name)"
    done <<< "$funcs"

    env_after="$(env)"
    export VARS=$(sort <(echo "$env_before" ) <(echo "$env_after") | uniq -u)
    echo
    npx task print-vars
}

function extract_function_names {
    pattern="function (.+) "
    while IFS= read -r line
    do
        [[ $line =~ $pattern ]] && echo "${BASH_REMATCH[1]}"
    done < "$1"
}

function taskfile {
    task_name="$1"
    [ -z $task_name ] && echo "Task name is required" && exit 1
    task_paths=("$TASKS" "$TASK_LIBRARY_TASKS")
    for task_path in ${task_paths[@]}; do [ -f "$task_path/$task_name" ] && task_file="$task_path/$task_name" && break; done
    echo "$task_file"
}

function warn_unset {
    [ ! -z ${!1} ] && echo -n "‚ö†Ô∏è  $1 is unset"
    [ ! -z "$2" ] && echo -n ". Defaulting to ${BOLD}$2${NORM}"
    echo
}

function ask_continue {
    echo
    read -p "üëÄ Continue? " choice
    case "$choice" in 
        y|Y ) echo;;
        n|N ) echo "Aborting..."; echo; exit 1;;
        * ) echo "Invalid input. Aborting..."; echo; exit 1;;
    esac
}

function package {
    echo $(cat ./package.json | jq -r ".$1 // empty")
}

function has_dependency {
    found=$(jq ".dependencies | has(\"$1\")" "$PACKAGE")
    [ $found = "true" ]
    return "$?"
}

function has_dev_dependency {
    found=$(jq ".devDependencies | has(\"$1\")" "$PACKAGE")
    [ $found = "true" ]
    return "$?"
}

function has_any_dependency {
    has_dependency "$1" || has_dev_dependency "$1"
    return "$?"
}

function now { 
    node -p "Date.now()" 
}

function ssm {
    echo $(aws ssm get-parameter --region $AWS_REGION --name "$1" --with-decryption | jq -r '.Parameter.Value')
}

function is_on_npm {
    npm view > /dev/null 2>&1
    return "$?"
}

function is_on_ghp {    
    status_code=$(curl -s -o /dev/null -I -w "%{http_code}" "$GITHUB_PAGES_URL/") # trailing slash is needed
    [[ $status_code = "200" || $status_code = "301" ]]
    return "$?"
}

function is_on_sls {
    [ -f "./serverless.yml" ]
    return "$?"
}

export -f load_vars
export -f taskfile
export -f ask_continue
export -f warn_unset
export -f package 
export -f has_dependency
export -f has_dev_dependency
export -f has_any_dependency
export -f now
export -f ssm
export -f is_on_npm
export -f is_on_ghp
export -f is_on_sls
