#!/bin/bash

export NORM=$(tput sgr0)
export BOLD=$(tput bold)
export RED=$(tput setaf 1)
export GRE=$(tput setaf 2)
export YEL=$(tput setaf 3)

function task {
    task_name=${1:-default}
    [ -z "$VARS" ] && load_vars
    task_file=$(taskfile $task_name)
    [ -z "$task_file" ] && echo -e "Task ${BOLD}$task_name${NORM} not found" && exit 1
    chmod +x "$task_file"
    echo "${NORM}⚡️ Task ${BOLD}$task_name${NORM} started" # Source: $task_file"
    time_before=$(now)
    "$task_file" "${@:2}"
    exit_code=$?
    time_after=$(now)
    time_taken_ms=$((time_after-time_before))
    time_taken_s=$(echo "scale=1;${time_taken_ms}/1000" | bc)
    [[ $time_taken_s == .* ]] && time_taken_s="0$time_taken_s"
    [ $exit_code = 0 ] && icon="✅" || icon="❌"
    echo "${NORM}${icon} Task ${BOLD}$task_name${NORM} completed with exit code $exit_code in ${time_taken_ms}ms (${time_taken_s}s)"
    exit $exit_code
}

function load_vars {
    env_before="$(env)"
    source "./task-vars" 2> /dev/null
    vars=$(extract_function_names "$TASK_LIBRARY_ROOT/src/bash/var-functions")

    while IFS= read -r name; do
        [ -z "${!name}" ] && export $name="$($name)"
    done <<< "$vars"

    env_after="$(env)"
    export VARS=$(sort <(echo "$env_before" ) <(echo "$env_after") | uniq -u)
    echo
    npx task print-vars
}

function taskfile {
    task_name="$1"
    [ -z "$task_name" ] && echo "Task name is required" && exit 1
    function mapper { echo "$1/$task_name"; }
    paths=$(map "$TASK_PATHS" mapper)
    function predicate { [ -f "$1" ]; }
    find "$paths" predicate
}

function warn {
    echo "   ${YEL}$1${NORM}" >&2
}

function ask_continue {
    echo
    read -p "👀 Continue? " choice
    case "$choice" in 
        y|Y ) echo;;
        n|N ) echo "Aborting..."; echo; exit 1;;
        * ) echo "Invalid input. Aborting..."; echo; exit 1;;
    esac
}

function package {
    echo $(cat ./package.json | jq -r ".$1 // empty")
}

function has_dependency {
    found=$(jq ".dependencies | has(\"$1\")" "$PACKAGE_JSON")
    [ $found = "true" ]
    return "$?"
}

function has_dev_dependency {
    found=$(jq ".devDependencies | has(\"$1\")" "$PACKAGE_JSON")
    [ $found = "true" ]
    return "$?"
}

function has_any_dependency {
    has_dependency "$1" || has_dev_dependency "$1"
    return "$?"
}

function npm_install {
    options="$1"
    packages="${@:2}"
    [ "$packages" ] && message=" ${BOLD}$packages${NORM}"
    echo -n "Installing$message..."
    output=$(npm i $options $packages 2>&1)
    [ $? ] && echo " done" && return 0
    echo " done with errors"
    echo "$output"
}

function node_script {
    node "$TASK_LIBRARY_ROOT/src/node/bin/$1" "${@:2}"
}

function node_module {
    node \
        --experimental-specifier-resolution="node" \
        --input-type="module" \
        - < "$TASK_LIBRARY_ROOT/src/node/bin/$1" "${@:2}"
}

function export_staged {
    source_name=$(echo "$1_$STAGE" | tr '[:lower:]' '[:upper:]')
    val=${!source_name}
    dest_name=$(echo "$1" | tr '[:lower:]' '[:upper:]')
    export $dest_name=$val
}

function flat {
    find "$1/" -mindepth 2 -type f -exec mv -i '{}' "$1/" ';'
    find "$1/" -type d -empty -delete
}

function port {
    node "$TASK_LIBRARY_ROOT/src/node/bin/port-gen" "$1"
}

function now {
    node -p "Date.now()" 
}

function ssm {
    echo $(aws ssm get-parameter --region $AWS_REGION --name "$1" --with-decryption | jq -r '.Parameter.Value')
}

function is_on_npm {
    npm view > /dev/null 2>&1
    return "$?"
}

function is_on_ghp {
    status_code=$(curl -s -o /dev/null -I -w "%{http_code}" "$GITHUB_PAGES_URL/") # trailing slash is needed
    [[ $status_code = "200" || $status_code = "301" ]]
    return "$?"
}

function is_on_sls {
    [ -f "$SERVERLESS_CONFIG" ]
    return "$?"
}

function join {
    local sep=${2:-$SEP}
    echo "${1//${IFS:0:1}/$sep}"
}

function find {
    local IFS="$SEP"
    local arr=($1) # splits on each character of $IFS (space or pipe)
    local fun=$2
    for el in "${arr[@]}"; do $fun "$el" && echo "$el" && break; done
}

function filter {
    local IFS="$SEP"
    local arr=($1) # splits on each character of $IFS (space or pipe)
    local fun=$2
    local out_sep="$3"
    local res=()
    for el in "${arr[@]}"; do $fun "$el" && res+=("$el"); done
    join "${res[*]}" "$out_sep" # joins on first character of $IFS (space)
}

function map {
    local IFS="$SEP"
    local arr=($1) # splits on each character of $IFS (space or pipe)
    local fun=$2
    local out_sep="$3"
    local res=()
    for el in "${arr[@]}"; do res+=($($fun "$el")); done
    join "${res[*]}" "$out_sep" # joins on first character of $IFS (space)
}

function for_each {
    local IFS="$SEP"
    local arr=($1) # splits on each character of $IFS (space or pipe)
    local fun=$2
    for el in "${arr[@]}"; do $fun "$el"; done
}
