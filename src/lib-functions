#!/bin/bash

export NORM=$(tput sgr0)
export BOLD=$(tput bold)
export RED=$(tput setaf 1)
export GRE=$(tput setaf 2)

function task {
    task_name=${1:-default}
    [ -z "$VARS" ] && load_vars
    task_file=$(taskfile $task_name)
    [ -z "$task_file" ] && echo -e "Task ${BOLD}$task_name${NORM} not found" && exit 1
    chmod +x "$task_file"
    echo "${NORM}⚡️ Task ${BOLD}$task_name${NORM} started" # Source: $task_file"
    time_before=$(now)
    "$task_file" "${@:2}"
    exit_code=$?
    time_after=$(now)
    time_taken_ms=$((time_after-time_before))
    time_taken_s=$(echo "scale=1;${time_taken_ms}/1000" | bc)
    [[ $time_taken_s == .* ]] && time_taken_s="0$time_taken_s"
    [ $exit_code = 0 ] && icon="✅" || icon="❌"
    echo "${NORM}${icon} Task ${BOLD}$task_name${NORM} completed with exit code $exit_code in ${time_taken_ms}ms (${time_taken_s}s)"
    exit $exit_code
}

function load_vars {
    env_before="$(env)"
    source "./task-vars" 2> /dev/null
    vars=$(extract_function_names "$TASK_LIBRARY_ROOT/src/var-functions")

    while IFS= read -r name; do
        [ -z "${!name}" ] && export $name="$($name)"
    done <<< "$vars"

    env_after="$(env)"
    export VARS=$(sort <(echo "$env_before" ) <(echo "$env_after") | uniq -u)
    echo
    npx task print-vars
}

function taskfile {
    task_name="$1"
    [ -z $task_name ] && echo "Task name is required" && exit 1
    task_paths=("$TASKS" "$TASK_LIBRARY_ROOT/src/tasks")
    for task_path in ${task_paths[@]}; do [ -f "$task_path/$task_name" ] && task_file="$task_path/$task_name" && break; done
    echo "$task_file"
}

function node_script {
    node "$TASK_LIBRARY_ROOT/src/bin/$1" "${@:2}"
}

function node_module {
    node \
        --experimental-specifier-resolution="node" \
        --input-type="module" \
        - < "$TASK_LIBRARY_ROOT/src/bin/$1" "${@:2}"
}

function warn_unset {
    [ ! -z ${!1} ] && echo -n "⚠️  $1 is unset"
    [ ! -z "$2" ] && echo -n ". Defaulting to ${BOLD}$2${NORM}"
    echo
}

function ask_continue {
    echo
    read -p "👀 Continue? " choice
    case "$choice" in 
        y|Y ) echo;;
        n|N ) echo "Aborting..."; echo; exit 1;;
        * ) echo "Invalid input. Aborting..."; echo; exit 1;;
    esac
}

function package {
    echo $(cat ./package.json | jq -r ".$1 // empty")
}

function has_dependency {
    found=$(jq ".dependencies | has(\"$1\")" "$PACKAGE_JSON")
    [ $found = "true" ]
    return "$?"
}

function has_dev_dependency {
    found=$(jq ".devDependencies | has(\"$1\")" "$PACKAGE_JSON")
    [ $found = "true" ]
    return "$?"
}

function has_any_dependency {
    has_dependency "$1" || has_dev_dependency "$1"
    return "$?"
}

function npm_install {
    options="$1"
    packages="${@:2}"
    [ "$packages" ] && message=" ${BOLD}$packages${NORM}"
    echo -n "Installing$message..."
    output=$(npm i $options $packages 2>&1)
    [ $? ] && echo " done" && return 0
    echo " done with errors"
    echo "$output"
}

function export_staged {
    source_name=$(echo "$1_$STAGE" | tr '[:lower:]' '[:upper:]')
    val=${!source_name}
    dest_name=$(echo "$1" | tr '[:lower:]' '[:upper:]')
    export $dest_name=$val
}

function flat {
    find "$1/" -mindepth 2 -type f -exec mv -i '{}' "$1/" ';'
    find "$1/" -type d -empty -delete
}

function port {
    node "$TASK_LIBRARY_ROOT/src/bin/port-gen" "$1"
}

function now {
    node -p "Date.now()" 
}

function ssm {
    echo $(aws ssm get-parameter --region $AWS_REGION --name "$1" --with-decryption | jq -r '.Parameter.Value')
}

function is_on_npm {
    npm view > /dev/null 2>&1
    return "$?"
}

function is_on_ghp {
    status_code=$(curl -s -o /dev/null -I -w "%{http_code}" "$GITHUB_PAGES_URL/") # trailing slash is needed
    [[ $status_code = "200" || $status_code = "301" ]]
    return "$?"
}

function is_on_sls {
    [ -f "$SERVERLESS_CONFIG" ]
    return "$?"
}


function join {
    echo "${1// /$SEP}"
}

function filter {
    local IFS="$SEP"
    local arr=($1)
    local predicate=$2
    local results=()

    for item in "${arr[@]}"; do
        $predicate "$item"
        [ $? -eq 0 ] && results+=("$item")
    done

    join "${results[*]}"
}
